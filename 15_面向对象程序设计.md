<!--
 * @Descripttion: 
 * @version: 
 * @Author: LiuZhiYi
 * @Date: 2023-08-09 20:30:14
 * @LastEditTime: 2023-08-10 13:56:45
-->
# OOP


## 基类和派生类

### 类型转换
- 派生类向基类的类型转换只对引用或指针有效
- 基类向派生类不存在隐式类型转换（使用`dynamic_cast`或`static_cast`）
- 派生类向基类的类型转换可能因为访问受限而不可行
- 可以将一个派生类对象拷贝、移动或赋值给一个基类对象，这种操作只能处理派生类的基类部分
## 虚函数
- 对虚函数调用可能在运行时才被解析
  - 通过普通类型表达式调用虚函数，编译时确定版本
  - 通过指针或引用调用虚函数时，动态绑定才会发生
- 当派生类希望调用基类版本的虚函数时，回避虚函数
  - 不管baseP的类型，直接调用Quote的函数版本；编译时确定版本
  ~~~c++
  double p = baseP->Quote::net_price(42);
  ~~~

  ## 访问控制与继承
- 对基类成员的访问权限只与基类的访问说明符有关
- 派生访问说明符的目的是控制派生类用户对于基类成员的访问权限
~~~c++
class Base{
public:
  void pub_mem();
protected:
  int prot_mem;
private:
  char priv_mem;
};

struct Pub : public Base {
  // 派生类可以访问protected成员
  int f() {return prot_mem;}
};

struct Priv : private Base {
  // private不影响派生类访问权限
  int f1() const {return prot_mem;}
};

Pub p1; Priv p2;
p1.pub_mem(); // 派生类中是public的
p2.pub_mem(); // 错误，派生类中是private的
~~~




